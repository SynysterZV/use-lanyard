{"version":3,"sources":["../src/index.ts","../src/hooks/rest.ts","../src/context/context.ts","../src/types.ts","../src/utils/get.ts","../src/hooks/socket.ts"],"sourcesContent":["export * from './hooks';\nexport * from './types';\nexport * from './utils/get';\n","import {useCallback, useEffect, useState} from 'react';\nimport {ContextData, useLanyardContext} from '../context/context';\nimport {API, DEFAULT_OPTIONS, Options, Snowflake} from '../types';\nimport {get, getURL} from '../utils/get';\n\nexport type UseLanyardReturn = ContextData & {\n\trevalidate(): Promise<void>;\n};\n\nexport class LanyardError extends Error {\n\tpublic readonly code: number;\n\n\tconstructor(\n\t\tpublic readonly request: Request,\n\t\tpublic readonly response: Response,\n\t\tpublic readonly body: API.ErroredAPIResponse,\n\t) {\n\t\tsuper(body.error.message);\n\t\tthis.code = this.response.status;\n\t}\n}\n\nexport function useLanyard(\n\tsnowflake: Snowflake,\n\t_options?: Partial<Options>,\n): UseLanyardReturn {\n\tconst options: Options = {\n\t\t...DEFAULT_OPTIONS,\n\t\t..._options,\n\t};\n\n\tconst [, rerender] = useState({});\n\tconst context = useLanyardContext();\n\n\tif (!context.stateMap.has(snowflake)) {\n\t\tcontext.stateMap.set(snowflake, {\n\t\t\tstate: 'initial',\n\t\t\tisLoading: false,\n\t\t\tdata: options.initialData,\n\t\t\terror: undefined,\n\t\t});\n\t}\n\n\tconst dispatch = (data: ContextData) => {\n\t\tcontext.stateMap.set(snowflake, data);\n\n\t\tfor (const listener of context.listeners) {\n\t\t\tlistener();\n\t\t}\n\t};\n\n\tconst getState = () => {\n\t\tconst data = context.stateMap.get(snowflake);\n\n\t\tif (!data) {\n\t\t\tthrow new Error('State not found');\n\t\t}\n\n\t\treturn data;\n\t};\n\n\tconst loading = (isLoading: boolean) => {\n\t\tdispatch({\n\t\t\t...getState(),\n\t\t\tisLoading,\n\t\t});\n\t};\n\n\tconst url = getURL(snowflake, options);\n\n\tconst revalidate = useCallback(\n\t\tasync (controller?: AbortController) => {\n\t\t\tif (getState().isLoading) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tloading(true);\n\n\t\t\tconst result = await get(\n\t\t\t\turl,\n\t\t\t\tcontroller ? {...options, controller} : options,\n\t\t\t);\n\n\t\t\tif (result.error) {\n\t\t\t\tdispatch({\n\t\t\t\t\t...getState(),\n\t\t\t\t\tstate: 'errored',\n\t\t\t\t\terror: result.error,\n\t\t\t\t\tisLoading: false,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdispatch({\n\t\t\t\t\t...getState(),\n\t\t\t\t\tstate: 'loaded',\n\t\t\t\t\tdata: result.data,\n\t\t\t\t\tisLoading: false,\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t[url],\n\t);\n\n\tuseEffect(() => {\n\t\tconst listener = () => rerender({});\n\t\tcontext.listeners.add(listener);\n\n\t\tconst controller = new AbortController();\n\n\t\tvoid revalidate().finally(() => {\n\t\t\tloading(false);\n\t\t});\n\n\t\treturn () => {\n\t\t\tcontroller.abort();\n\t\t\tcontext.listeners.delete(listener);\n\t\t};\n\t}, [revalidate]);\n\n\treturn {\n\t\t...getState(),\n\n\t\t// We want to make sure users cannot pass any arguments into this function\n\t\t// for example, when doing <button onClick={revalidate} />\n\t\trevalidate: useCallback(() => revalidate(), [revalidate]),\n\t};\n}\n\nexport default useLanyard;\n","import {createContext, useContext} from 'react';\nimport {LanyardError} from '../hooks';\nimport {Data, Snowflake} from '../types';\n\nexport type ContextData =\n\t| {\n\t\t\tstate: 'initial';\n\t\t\tisLoading: boolean;\n\t\t\terror: undefined;\n\n\t\t\t// Data could exist at this initial stage\n\t\t\t// because of.initialData in options\n\t\t\tdata: Data | undefined;\n\t  }\n\t| {\n\t\t\tstate: 'loaded';\n\t\t\tisLoading: boolean;\n\t\t\tdata: Data;\n\t\t\terror: LanyardError | undefined;\n\t  }\n\t| {\n\t\t\tstate: 'errored';\n\t\t\tisLoading: boolean;\n\t\t\tdata: Data | undefined;\n\t\t\terror: LanyardError | undefined;\n\t  };\n\nexport function useLanyardContext() {\n\treturn useContext(context);\n}\n\nexport type Context = {\n\tlisteners: Set<() => void>;\n\tstateMap: Map<Snowflake, ContextData>;\n};\n\nexport const context = createContext<Context>({\n\tlisteners: new Set(),\n\tstateMap: new Map(),\n});\n","export namespace API {\n\texport type SuccessfulAPIResponse<T> = {\n\t\tsuccess: true;\n\t\tdata: T;\n\t};\n\n\texport type ErroredAPIResponse = {\n\t\tsuccess: false;\n\t\terror: {message: string; code: string};\n\t};\n}\n\nexport type Options = {\n\t/**\n\t * The Base URL of Lanyard's API. Defaults to `https://api.lanyard.rest`\n\t */\n\tapi: {\n\t\thostname: string;\n\t\tsecure?: boolean;\n\t};\n\n\t/**\n\t * Initial data to use. Useful if server side rendering.\n\t */\n\tinitialData?: Data;\n};\n\nexport const DEFAULT_OPTIONS: Options = {\n\tapi: {\n\t\thostname: 'api.lanyard.rest',\n\t\tsecure: true,\n\t},\n};\n\nexport type Snowflake = `${bigint}`;\n\nexport type LanyardResponse =\n\t| API.SuccessfulAPIResponse<Data>\n\t| API.ErroredAPIResponse;\n\nexport interface Data {\n\tspotify: Spotify | null;\n\tkv: Record<string, string>;\n\tlistening_to_spotify: boolean;\n\tdiscord_user: DiscordUser;\n\tdiscord_status: 'online' | 'idle' | 'dnd' | 'offline';\n\tactivities: Activity[];\n\tactive_on_discord_web: boolean;\n\tactive_on_discord_mobile: boolean;\n\tactive_on_discord_desktop: boolean;\n}\n\nexport interface Spotify {\n\ttrack_id: string | null;\n\ttimestamps: Timestamps;\n\tsong: string;\n\tartist: string;\n\talbum_art_url: string | null;\n\talbum: string;\n}\n\nexport interface Timestamps {\n\tstart: number;\n\tend: number;\n}\n\nexport interface DiscordUser {\n\tusername: string;\n\tpublic_flags: number;\n\tid: Snowflake;\n\tglobal_name: string | null;\n\t/**\n\t * @deprecated Use global_name instead.\n\t */\n\tdisplay_name: string | null;\n\tdiscriminator: string;\n\tbot: boolean;\n\tavatar_decoration: string | null;\n\tavatar: string | null;\n}\n\nexport interface Activity {\n\ttype: number;\n\tstate: string;\n\tname: string;\n\tid: string;\n\temoji?: Emoji;\n\tcreated_at: number;\n\ttimestamps?: Timestamps;\n\tsync_id?: string;\n\tsession_id?: string;\n\tparty?: Party;\n\tflags?: number;\n\tdetails?: string;\n\tassets?: Assets;\n\tapplication_id?: Snowflake;\n}\n\nexport interface Emoji {\n\tname: string;\n\tid: Snowflake;\n\tanimated: boolean;\n}\n\nexport interface Party {\n\tsize: [number, number];\n\tid: string;\n}\n\nexport interface Assets {\n\tsmall_text: string;\n\tsmall_image: string;\n\tlarge_text: string;\n\tlarge_image: string;\n}\n","import {LanyardResponse, Options, Snowflake} from '../types';\nimport {LanyardError} from '../hooks/rest';\n\nexport interface GetOptions extends Options {\n\tcontroller?: AbortController;\n}\n\nexport function getURL(snowflake: Snowflake, options: Options) {\n\tconst protocol = options.api.secure ? ('https' as const) : ('http' as const);\n\n\treturn `${protocol}://${options.api.hostname}/v1/users/${snowflake}` as const;\n}\n\nexport async function get(url: ReturnType<typeof getURL>, options: GetOptions) {\n\tconst init: RequestInit = {\n\t\tmethod: 'GET',\n\t\tsignal: options.controller?.signal ?? null,\n\t\theaders: {Accept: 'application/json'},\n\t};\n\n\tconst request = new Request(url, init);\n\tconst response = await fetch(request);\n\n\tconst body = (await response.json()) as LanyardResponse;\n\n\tif (!body.success) {\n\t\treturn {\n\t\t\tsuccess: false as const,\n\t\t\terror: new LanyardError(request, response, body),\n\t\t};\n\t}\n\treturn {\n\t\tsuccess: true as const,\n\t\tdata: body.data,\n\t};\n}\n","import {useEffect, useState} from 'react';\nimport {Options, Data, Snowflake, DEFAULT_OPTIONS} from '../types';\n\nexport enum SocketOpcode {\n\tEvent,\n\tHello,\n\tInitialize,\n\tHeartbeat,\n}\n\nexport enum SocketEvents {\n\tINIT_STATE = 'INIT_STATE',\n\tPRESENCE_UPDATE = 'PRESENCE_UPDATE',\n}\n\nexport interface SocketData extends Data {\n\theartbeat_interval?: number;\n}\n\nexport interface SocketMessage {\n\top: SocketOpcode;\n\tt?: SocketEvents;\n\td?: SocketData;\n}\n\nexport function useLanyardWS(\n\tsnowflake: Snowflake | Snowflake[],\n\t_options?: Partial<Options>,\n) {\n\tconst options = {\n\t\t...DEFAULT_OPTIONS,\n\t\t..._options,\n\t};\n\n\tconst [data, setData] = useState<Data>();\n\n\tconst protocol = options.api.secure ? 'wss' : 'ws';\n\tconst url = `${protocol}://${options.api.hostname}/socket`;\n\n\tuseEffect(() => {\n\t\t// Don't try to connect on server\n\t\tif (typeof window === 'undefined') {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!('WebSocket' in window || 'MozWebSocket' in window)) {\n\t\t\tthrow new Error('WebSocket connections not supported in this browser.');\n\t\t}\n\n\t\tlet subscribe_data: {subscribe_to_ids?: string[]; subscribe_to_id?: string};\n\n\t\tif (typeof snowflake === 'object') {\n\t\t\tsubscribe_data = {subscribe_to_ids: snowflake};\n\t\t} else {\n\t\t\tsubscribe_data = {subscribe_to_id: snowflake};\n\t\t}\n\n\t\tlet heartbeat: ReturnType<typeof setTimeout>;\n\t\tlet socket: WebSocket;\n\n\t\tfunction connect() {\n\t\t\tif (heartbeat) {\n\t\t\t\tclearInterval(heartbeat);\n\t\t\t}\n\n\t\t\tsocket = new WebSocket(url);\n\n\t\t\tsocket.addEventListener('open', () => {\n\t\t\t\tconsole.log('Lanyard: Socket connection opened');\n\t\t\t});\n\n\t\t\tsocket.addEventListener('close', connect);\n\n\t\t\tsocket.addEventListener('message', event => {\n\t\t\t\tconst message = JSON.parse(event.data) as SocketMessage;\n\n\t\t\t\tswitch (message.op) {\n\t\t\t\t\tcase SocketOpcode.Hello: {\n\t\t\t\t\t\theartbeat = setInterval(() => {\n\t\t\t\t\t\t\tif (socket.readyState === socket.OPEN) {\n\t\t\t\t\t\t\t\tsocket.send(JSON.stringify({op: SocketOpcode.Heartbeat}));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, message.d?.heartbeat_interval);\n\n\t\t\t\t\t\tif (socket.readyState === socket.OPEN) {\n\t\t\t\t\t\t\tsocket.send(\n\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\top: SocketOpcode.Initialize,\n\t\t\t\t\t\t\t\t\td: subscribe_data,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase SocketOpcode.Event: {\n\t\t\t\t\t\tswitch (message.t) {\n\t\t\t\t\t\t\tcase SocketEvents.INIT_STATE:\n\t\t\t\t\t\t\tcase SocketEvents.PRESENCE_UPDATE: {\n\t\t\t\t\t\t\t\tif (message.d) {\n\t\t\t\t\t\t\t\t\tsetData(message.d);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tconnect();\n\n\t\treturn () => {\n\t\t\tclearInterval(heartbeat);\n\n\t\t\tsocket.removeEventListener('close', connect);\n\t\t\tsocket.close();\n\t\t};\n\t}, [url]);\n\n\treturn data ?? options.initialData;\n}\n"],"mappings":"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","names":["src_exports","__export","DEFAULT_OPTIONS","LanyardError","SocketEvents","SocketOpcode","get","getURL","useLanyard","useLanyardWS","__toCommonJS","import_react","import_react","useLanyardContext","context","DEFAULT_OPTIONS","getURL","snowflake","options","get","url","init","request","response","body","LanyardError","LanyardError","request","response","body","useLanyard","snowflake","_options","options","DEFAULT_OPTIONS","rerender","context","useLanyardContext","dispatch","data","listener","getState","loading","isLoading","url","getURL","revalidate","controller","result","get","import_react","SocketOpcode","SocketEvents","useLanyardWS","snowflake","_options","options","DEFAULT_OPTIONS","data","setData","url","subscribe_data","heartbeat","socket","connect","event","message"]}