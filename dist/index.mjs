import{useCallback as y,useEffect as w,useState as L}from"react";import{createContext as _,useContext as S}from"react";function b(){return S(E)}var E=_({listeners:new Set,stateMap:new Map});var f={api:{hostname:"api.lanyard.rest",secure:!0}};function g(a,o){return`${o.api.secure?"https":"http"}://${o.api.hostname}/v1/users/${a}`}async function x(a,o){let n={method:"GET",signal:o.controller?.signal??null,headers:{Accept:"application/json"}},l=new Request(a,n),e=await fetch(l),i=await e.json();return i.success?{success:!0,data:i.data}:{success:!1,error:new m(l,e,i)}}var m=class extends Error{constructor(n,l,e){super(e.error.message);this.request=n;this.response=l;this.body=e;this.code=this.response.status}code};function q(a,o){let n={...f,...o},[,l]=L({}),e=b();e.stateMap.has(a)||e.stateMap.set(a,{state:"initial",isLoading:!1,data:n.initialData,error:void 0});let i=r=>{e.stateMap.set(a,r);for(let s of e.listeners)s()},c=()=>{let r=e.stateMap.get(a);if(!r)throw new Error("State not found");return r},p=r=>{i({...c(),isLoading:r})},d=g(a,n),t=y(async r=>{if(c().isLoading)return;p(!0);let s=await x(d,r?{...n,controller:r}:n);s.error?i({...c(),state:"errored",error:s.error,isLoading:!1}):i({...c(),state:"loaded",data:s.data,isLoading:!1})},[d]);return w(()=>{let r=()=>l({});e.listeners.add(r);let s=new AbortController;return t().finally(()=>{p(!1)}),()=>{s.abort(),e.listeners.delete(r)}},[t]),{...c(),revalidate:y(()=>t(),[t])}}import{useEffect as v,useState as D}from"react";var A=(e=>(e[e.Event=0]="Event",e[e.Hello=1]="Hello",e[e.Initialize=2]="Initialize",e[e.Heartbeat=3]="Heartbeat",e))(A||{}),T=(n=>(n.INIT_STATE="INIT_STATE",n.PRESENCE_UPDATE="PRESENCE_UPDATE",n))(T||{});function K(a,o){let n={...f,...o},[l,e]=D(),c=`${n.api.secure?"wss":"ws"}://${n.api.hostname}/socket`;return v(()=>{if(typeof window>"u")return;if(!("WebSocket"in window||"MozWebSocket"in window))throw new Error("WebSocket connections not supported in this browser.");let p;typeof a=="object"?p={subscribe_to_ids:a}:p={subscribe_to_id:a};let d,t;function r(){d&&clearInterval(d),t=new WebSocket(c),t.addEventListener("open",()=>{console.log("Lanyard: Socket connection opened")}),t.addEventListener("close",r),t.addEventListener("message",s=>{let u=JSON.parse(s.data);switch(u.op){case 1:{d=setInterval(()=>{t.readyState===t.OPEN&&t.send(JSON.stringify({op:3}))},u.d?.heartbeat_interval),t.readyState===t.OPEN&&t.send(JSON.stringify({op:2,d:p}));break}case 0:{switch(u.t){case"INIT_STATE":case"PRESENCE_UPDATE":{u.d&&e(u.d);break}default:break}break}default:break}})}return r(),()=>{clearInterval(d),t.removeEventListener("close",r),t.close()}},[c]),l??n.initialData}export{f as DEFAULT_OPTIONS,m as LanyardError,T as SocketEvents,A as SocketOpcode,x as get,g as getURL,q as useLanyard,K as useLanyardWS};
//# sourceMappingURL=index.mjs.map